// geeksforgeeks version of merge k sorted linked lists
/*
class Node {
  public:
    int data;
    Node* next;

    Node(int x){
        data = x;
        next = NULL;
    }
};
*/

class Solution {
  public:
    Node* mergeTwoLists(Node* &l1, Node* &l2) {
        if(l1 == NULL) return l2;
        if(l2 == NULL) return l1;
        if(l1 == NULL && l2 == NULL) return NULL;
        if(l1->data < l2->data) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        }
        else {
            l2->next = mergeTwoLists(l1, l2->next);
            return l2;
        }
    }
    Node* partitionAndMerge(vector<Node*> &arr, int start, int end) {
        if(start > end) {
            return NULL;
        }
        if(start == end) {
            return arr[start];
        }
        
        int mid = start + (end - start)/2;
        
        Node* L1 = partitionAndMerge(arr, start, mid);
        Node* L2 = partitionAndMerge(arr, mid + 1, end);
        
        return mergeTwoLists(L1, L2);
    }
    Node* mergeKLists(vector<Node*>& arr) {
        int n = arr.size();
        int start = 0;
        int end = n - 1;
        
        if(n == 0) {
            return NULL;
        }
        
        return partitionAndMerge(arr, start, end);
    }
};








// Row version of merge k sorted linked lists
#include<bits/stdc++.h>
using namespace std;

class LinkedList {
    public:
        int data;
        LinkedList* next;
        
        LinkedList(int data) {
            this->data = data;
            this->next = NULL;
        }
};

void insertAtEnd(LinkedList* &head, int data) {
    LinkedList* newList = new LinkedList(data);
    LinkedList* temp = head;
    
    if (head == NULL) {
        head = newList;
        return;
    }
    
    while(temp->next != NULL) {
        temp = temp->next;
    }
    temp->next = newList;
}

void printLinkedList(LinkedList* &head) {
    while(head != NULL) {
        cout<<head->data<<" ";
        head = head->next;
    }
}

LinkedList* mergeTwoLists(LinkedList* &L1, LinkedList* &L2) {
    if(L1 == NULL) return L2;
    if(L2 == NULL) return L1;
    
    if(L1->data < L2->data) {
        L1->next = mergeTwoLists(L1->next, L2);
        
        return L1;
    }
    else {
        L2->next = mergeTwoLists(L1, L2->next);
        
        return L2;
    }
}

LinkedList* partitionAndMerge(int start, int end, vector<LinkedList*> &lists) {
    if(start > end) {
        return NULL;
    }
    if(start == end) {
        return lists[start];
    }
    int mid = start + (end - start)/2;
    LinkedList* L1 = partitionAndMerge(start, mid, lists);
    LinkedList* L2 = partitionAndMerge(mid + 1, end, lists);
    
    return mergeTwoLists(L1, L2);
}

int main() {
    
    LinkedList* head1 = NULL;
    LinkedList* head2 = NULL;
    LinkedList* head3 = NULL;
    
    insertAtEnd(head1, 10);
    insertAtEnd(head1, 11);
    insertAtEnd(head1, 102);
    insertAtEnd(head1, 103);
    insertAtEnd(head1, 105);
    
    insertAtEnd(head2, 1);
    insertAtEnd(head2, 5);
    insertAtEnd(head2, 7);
    insertAtEnd(head3, 9);
    
    insertAtEnd(head3, 71);
    insertAtEnd(head3, 85);
    insertAtEnd(head3, 92);
    
    vector<LinkedList*> lists = {head1, head2, head3};
    int K = lists.size();
    LinkedList* mergedSortedKList = partitionAndMerge(0, K - 1, lists);
    
    printLinkedList(mergedSortedKList);
    
    
    return 0;
}
